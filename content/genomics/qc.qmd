# Quality control, trimming and screening sequence reads

The first step in our pipeline deals with assessing the quality of our sequence reads. These are provided to us by the sequencer in the form of `FASTQ` (or `fastq`) files. We already introduced this file format in a previous chapter (@sec-fastq), but we will dive in a bit deeper this time around.

## FASTQ file format revisited {#sec-fastq-in-depth}

The FASTQ file format holds the raw sequencing reads generated by next-generation sequencing technologies. For the Illumina platform, they contain the sequence data from the clusters on the flow cell (after some initial filtering steps) and these are the types of files that you would receive after a sequencing run. FASTQ files look superficially similar to FASTA files, in the sense that they hold sequence of nucleotides (strings of `ACTG` characters) preceded by an identifying header (`> ...`), but they also contain additional information that encodes the base quality scores.

::: {.callout-note}
## FASTQ files and Illumina sequencing

A more in-depth explanation on FASTQ files can be found on the [Illumina website](https://knowledge.illumina.com/software/general/software-general-reference_material-list/000002211).

If you need a refresh on the Illumina sequencing technology, i.e. cluster generation on flow cells and sequencing-by-synthesis, you can also check out this [video by ClevaLab](https://youtu.be/WKAUtJQ69n8?list=PLraUfmTsvBPYTVmFl0z1aFIQnZs0v8Huf).

<!-- {{< video https://www.youtube.com/watch?v=fCd6B5HRaZ8 >}} -->
<!-- {{< video https://www.youtube.com/watch?v=0vqajoP08Jg >}} -->
<!-- https://www.youtube.com/watch?v=PFwSe09dJX0 -->
<!-- https://www.youtube.com/watch?v=0cn8Q6RMINI -->

Lastly, you can also consult this [short course by Illumina](https://support.illumina.com/content/dam/illumina-support/courses/MiSeq_Imaging_and_Base_Calling/story_html5.html) on imaging and base calling for their MiSeq instruments.
:::

FASTQ files are plain-text files consisting of the following four lines for each sequence read:

| Line | Description                                                                                                                         |
| ---- | ----------------------------------------------------------------------------------------------------------------------------------- |
| 1    | Identifier or header: always starts with ‘@’ and contains information about the read (free format)                                  |
| 2    | The sequence of nucleotides making up the read                                                                                      |
| 3    | Always begins with a ‘+’ and sometimes repeats the identifier                                                                       |
| 4    | Contains a string of ASCII characters that represent the quality score for each base (i.e., it has the exact same length as line 2) |

FASTQ files generally contain many sequences, each of which might look something like this:

```
@M05795:43:000000000-CFLMP:1:1101:21302:1790 1:N:0:44
CCTCACCATGCAACCGATGCTCATCATGCAGCCGATGCTCATCATTCTCATCATGCACCCGCTGTCTCTTTTACACTTCTCCTTTCCCACGTCTCCCTTCTTTTTCTCCTATCCCTTCTTCTTCTTTCCCTCTTTTTTCTTTTTTCTTTTTCTCTTTTTTTCTTTTTTTCCCCTTTCTCTCTCTCTTTTCCTCTTCTTCTTCTTCTCTTCCTTCCCCCCCCCTTCCCTCTCCCCTCTCTCTTCCTCTTTCCCCCTTCTTTCCTTCCCCCCTCCCCCTTCCCTCCCCTTTCATCTCTTCCT
+
-AACCFGGGGGGGGFEGGCFGGCCFGGGGGGFDCCFGGEF9FA9F,6;C,CC,E,6,,;,++6+B6,<CE,6,6,9,95,,5,,,,,5,4+,,,,,9,,,,,5,5,9,,9,9,45,944,,5,4,9,,,,,,,,,,,+,,,,,,+,,,,,,,,,,,,,,++,,3,,,++,,,,,,,,,,,+++++++++++++1+++++++++++++++++++0****/())()/(()()(((((((())))))))))))))((((,))))))-),(((((((,((((((()(((((())-)-)))))))
```

The header line always starts with an `@` and usually carries information on the sequencing run, cluster on the flow cell or any other metadata. Note however that this format is not entirely fixed and depending on how and where your sequences were generated, the headers might look slightly different. In this case, the read was sequenced on an Illumina 1.8 sequencer, and we can identify the following types of metadata, separated by colons `:` and forward slashes `/` as field separators:

> `@<instrument>:<run number>:<flowcell ID>:<lane>:<tile>:<x-pos>:<y-pos> <read>:<is filtered>:<control number>:<barcode sequence>`
>
>  - `@`: start of the header
>  - `M05795`: unique sequencing instrument ID
>  - `43`: run number
>  - `000000000-CFLMP`: unique flow cell ID
>  - `1`: lane number (see below for more info on lanes)
>  - `1101`: tile number (= section of the lane)
>  - `21302`: x-coordinate of the cluster
>  - `1790`: y-coordinate of the cluster
>  - `1`: read number - 1 or 2 for paired-end sequencing
>  - `N`: not filtered
>  - `0`: control number
>  - `44`: index/barcode sequence (see below for more info on barcoding and multiplexing)
>
The second line contains the sequence as a string of characters. The third line is basically [a historical artifact](https://academic.oup.com/nar/article/38/6/1767/3112533#82650918) that we're now stuck with. The fourth line, containing the quality scores, will be explore in more detail in the next section (@sec-fastq-quality-score).

---

FASTQ files are typically named using the following convention:

> `SampleName_S1_L001_R1_001.fastq.gz`
>
> where:
>
> - `SampleName` is the name of the sample as it was provided in the samplesheet during submission, or a unique sample ID otherwise.
> - `S1` is the sample number, again based on the samplesheet.
> - `L001` is the lane number on the flow cell.
> - `R1` is the read pair - 1 or 2 for paired-end sequencing (or `I1`/`I2` for index reads).
> - `001`is always the last part of the name.
>
> Putting it all together, we end up with:
>
> `{sample_name}_S{sample number}_L{lane number}_{R/I}{read or index number}_001.fastq.gz`

::: {.callout-warning}
Keep in mind that these are conventions, not strict rules, so you will likely encounter file names that differ from the above.

Similar caveats apply to the header lines inside FASTQ files, as was mentioned above.
:::

Also, note that there is no standard file extension for FASTQ files, both `.fq` and `.fastq` are common. Keep in mind that file extensions in general are arbitrary; it is the file content that determines the file format, not the extension (although both Windows and Mac might try to convince you otherwise). However, using standard and descriptive file extensions makes everyone's life much easier.
<!-- TODO: section on file extensions -->

---

A sequencing run will generally produce either a single FASTQ file per sample (for single-end runs) or a pair of files per sample (for paired-end sequencing). For the latter, the files will bear identical file names, except for the suffix to distinguish them easily (and programmatically), usually either `_1`/`_2` or `R1`/`R2`. E.g., the two files might be called `SampleName_S1_L001_R1_001.fastq` and `SampleName_S1_L001_R1_001.fastq`. The forward and reverse read pairs are split across these two files and they always appear in the same order (or at least this is what most downstream tools expect). In some circumstances you might end up with a third file (either without a suffix or tagged as `_3`).

For deep sequencing, you might receive multiple files for each sample split across different lanes of the sequencer, in which case you might see files such as `SampleName_S1_L001_R1_001.fastq.gz`, `SampleName_S1_L002_R1_001.fastq.gz`. The lane descriptor is also important in the case of multiplexed samples.

::: {.callout-note}
## Multiplexed samples

It is often beneficial to pool samples from multiple individuals or projects together and then sequence them in a single run. It saves on costs, makes more efficient use of reagents and it also helps guard against batch effects. Every sequencing run, and even the different lanes of a single run, will introduce technical variation into your experiment. By pooling samples and loading them in the same lane (or across multiple lanes if more sequencing depth is required), this batch effect or bias can be reduced. When targeting specific genomic areas, like we do for AmpliSeq, or when working with small genomes in general, pooling allows us to analyse a large amount samples in a single run.




However, we cannot just throw the DNA from all these individuals
straight into the same tube and expect to be able to tell which reads come from which
individuals. In order to distinguish the DNA from different individuals or projects, we
must add index adapters and/or barcode adapters to each sample prior to pooling. The
process of demultiplexing (aka read parsing) involves using the sequence information from
these adapters to separate reads by sample. Thus, we can sequence many samples in the
same run, and afterwards be sure which reads came from which sample.


However, if we were to just throw together the DNA from all those different samples and load this mixture onto the sequencer, we would not be able to tell which reads came from which sample afterwards. In order to be able to distinguish reads from different samples, the library fragments need to be tagged with an index (or barcode, _naming conventions are messy_ [^indices]) that is unique to each sample, prior to pooling. The index is a unique oligonucleotide sequence that is read separately from the fragment of interest (called the insert), and depending on the technology used there might even be dual indices (on the 5' and 3' ends), placed between the fragment (and its sequencing primers) and the adapters (P5/P7, used to anneal the entire strand to the flow cell).

[^indices]: in practice, the terms index and barcodes are often used interchangeable for Illumina sequencing. However, two different types can be distinguished. Multiplex barcodes can be defined as indices which are part of the adapter regions and read out separately, and which are used for identifying the sample from which a fragment is derived. Inline barcodes are unique stretches of oligos inserted into the main fragment, and read out during the same reaction (i.e., they are part of the sequence read). In other technologies, like 10X single-cell sequencing, [barcodes are used to uniquely identify beads](https://kb.10xgenomics.com/hc/en-us/articles/115002777072-How-do-I-demultiplex-by-sample-index-and-barcode) (~ single cells), rather than multiplexed samples.

       https://www.umassmed.edu/contentassets/5ea3699998c442bb8c9b1a3cf95dbb24/indexing-and-barcoding-for-illumina-nextgen-sequencing.pdf
       https://teichlab.github.io/scg_lib_structs/methods_html/Illumina.html
       https://s3-us-west-2.amazonaws.com/oww-files-public/a/a5/IlluminaParsing_v1-2.pdf
       https://www.umassmed.edu/globalassets/deep-sequencing-core/illumina-library-structure_2021.pdf
       https://ngisweden.scilifelab.se/resources/index-guidelines-for-illumina-sequencing/
       https://knowledge.illumina.com/library-preparation/general/library-preparation-general-reference_material-list/000002344
       https://pathology.ecu.edu/genomics-core/basics/
       https://www.lubio.ch/blog/ngs-adapters


During sequencing, the indices of each cluster are read out (in a separate reaction from the fragment of interest, to avoid quality issues and ensure it is always complete), and afterwards this information is used to disentangle the different samples and generate (pairs of) FASTQ files per sample.

More information on multiplexing and index/barcode can be found here:

- [https://www.illumina.com/techniques/sequencing/ngs-library-prep/multiplexing.html](https://www.illumina.com/techniques/sequencing/ngs-library-prep/multiplexing.html)
-

:::

<!-- FASTQ files often come in pairs, which are usually named the same with a slightly different suffix (e.g., `sample_1_R1.fastq` and `sample_1_R2.fastq`). These pairs are reads of the same fragment in the opposite direction. In a nutshell, paired-end sequencing is used because the additional information provided by reads being paired can help with mapping repetitive regions of the genome. -->

---

FASTQ files can typically contain up to millions of reads (depending on the depth of sequencing), resulting in file sizes in the range of hundreds of MBs to multiple GBs. However, the files are usually compressed using `gzip` (receiving the `.fastq.gz` extension) to reduce their file size.

The raw FASTQ files forms the basis on which your analysis builds. No matter what analysis you might perform, you should be able to reproduce it if you can start from the same raw reads. It is therefor of utmost importance to properly manage these files and store them in a secure location, preferably backed up.


## Quality control (QC) {#sec-fastq-quality-score}

As mentioned above, `FASTQ` files contain information about:

- the raw sequence
- per base quality scores
- location of the cluster on the flow cell
- location of the base in the sequence
- nucleotide composition

These different types of information can all be used during QC of the reads.




unpaired reads
https://www.biostars.org/p/192788/

### Sources of errors

In Illumina sequencing, sequences reads are constructed by detecting the nucleotides present in each particular cluster ( = group of _identical_ elongated fragments) on a flow cell through a fluorescent signal. The intensity and purity of this signal is used to measure the quality of a particular base call, or in other words, how confident we can be that the base call at a particular position in the read is accurate.

There are a few issues inherent to the sequencing-by-synthesis process which can result in quality degradation, but the quality scores can also be indicative of more serious problems during the sequencing process or sample preparation.

- Signal decay
- Phasing
- Overclustering
- Instrument breakdown

Illumina base quality is reduced with each successive cycle due to phasing drift.

<!-- A common issue is the tendency for some fragments in a clonal cluster to not incorporate a nucleotide toward the end of the process, when sequencing reagents become more limiting. This leads to ambiguity in base calls near the 3’ end of reads.  -->

As a side note, all the different sequencing platforms suffer from incorrectly called bases due to technical limitations of the technology.

### Quality scores

The fourth line of each sequence in a `FASTQ` file contains the so called Phred Quality Scores $Q$. This line consists of a string of characters, one for each base in the sequence, that encodes the score for that base. The higher the score, the higher the probability that the base was called correctly (or the lower the probability of a misidentification). Specifically, the score is defined as follows:

$$ Q_{PHRED} = -10 \times \log_{10}(P_e) $$

Where $P_e$ is the probability of an incorrect base call. The following table gives an indication of how to interpret various ranges of quality scores:

| Phred Quality Score | Probability of incorrect base call | Base call accuracy |
|-----|---------------|-----|
| 10 | 1 in 10 | 90% |
| 20 | 1 in 100 | 99% |
| 30 | 1 in 1000 | 99.9% |
| 40 | 1 in 10,000 | 99.99%
| 50 | 1 in 100,000 | 99.999%
| 60 | 1 in 1,000,000 | 99.9999%

In general, Q30 is considered a good benchmark for

However, when you look at what is actually in the fourth line of a read in a FASTQ file you will see a rather strange collection of characters, including letters, numbers and other symbols, instead of, well, human-readable scores. What does a score of `@` even mean? Well, these are [ASCII characters](https://en.wikipedia.org/wiki/ASCII) and they are used to compress the Q scores (which are often 2 digit numbers) down into a single character. This not only saves space, but allows the score to be aligned with its corresponding base in the sequence.

<!-- FASTQ files do not contain the scores as a numerical value, why?
Instead, a single ASCII character is used to represent the quality score for each base.
The value is off-set by a base value (+33 for Illumina). -->

The characters in the ASCII set are tied to a particular Q score, but rather than starting from 0 (the first character in the ASCII set), each sequencing platform uses a particular off-set, i.e. they start at a unique base value and count up from there. For example, current Illumina platforms (1.8), use a Phred+33 encoding, in which a score of 0 corresponds to the character `!` and higher scores step through the range of characters from there. The Phred+33 encoding is visualised in green in the figure below.

![FASTQ quality scoring and ASCII offsets. [Source: @sequence-analysis-quality-control]](../assets/fastq-quality-encoding.png)

::: {.callout-tip collapse="true"}
## Interpreting Phred Quality Scores - example calculation

Consider the following Illumina 1.8 read:

```
@SR.1:Pf3D7_01_v3:M:533192-533407
TCTCATCATCCCTCTCATCATCATCATCACTCTCATCATTATCATCACTCTCATCACTCTCATTACTATCATCACTCTCATCATTATCATTACTATCATC
+
CABDAAFCBAHCEGFFA?FEEAFFHDCFCB?GHDECDCABFGBGA@HDGGEAABCDA@I?IIDIIH85:=;<:;;97:78:881//-23200&')$'(#%
```

The first base in the sequence (`T`) is associated with the encoded Q score `C`. On the table below, you can see that the value of this ASCII character is $67$. If we subtract the off-set, we get $67 - 33 = 34$, which is the Q score. Lastly, we need to rearrange the quality score equation shown above and plug in $Q$ in order to obtain the probability of an incorrect base call:

$$ P = 10^{\frac{Q}{-10}} = 10^{\frac{34}{-10}} \approx 0.0004 $$

Or a 0.9999% base call accuracy.

![ASCII table](../assets/ASCII-Table-wide.svg)

:::

To summarise, Q scores can be converted into the probability of base calling errors by performing the following steps:

1. Find the value of the ASCII character.
2. Convert into a Q score by subtracting the off-set value (e.g., -33).
3. Plug the resulting value into the formula $P = 10^{\frac{Q}{-10}}$ to obtain the error probability.
<!-- Note: equations inside lists should not have any white space around the $ symbols nor inside the equation, otherwise they won't render properly. -->

<!-- TODO add image https://mmbdtp.github.io/modules/sequencing/fastq-in-detail/ or same one here https://training.galaxyproject.org/training-material/topics/sequence-analysis/tutorials/quality-control/tutorial.html#inspect-a-raw-sequence-file-->

<!-- or https://en.wikipedia.org/wiki/FASTQ_format table -->

<!-- The current lllumina (1.8+) uses Sanger format (Phred+33). If you are working with older datasets you may encounter the older scoring schemes. FastQC tool, a tool we will use later in this tutorial, can be used to try to determine what type of quality encoding is used (through assessing the range of Phred values seen in the FASTQ). -->

::: {.callout-tip collapse="true"}
## Exercises

Given the following sequence from a sequencer using the current Illumina 1.8+ Sanger format.


```
@M00984:14:000000000-AA0HF:1:1101:23031:1298 1:N:0:1
CGTGCCAACGGCACTCGTACACGAGTTGTACAGAAACTGAT
+
CCCCCGGGGGGGGGGGGGGGGGGFDGGGGGGGFFGGGGG9F
```

- What is the Phred Quality Score of the first thymine in the following read?
- What is the probability that the final adenine is called correctly?
- Which ASCII characters correspond to the lowest and highest quality score?

:::

::: {.callout-note}

More information on Q scores can be found here:

- [https://www.illumina.com/documents/products/technotes/technote_Q-Scores.pdf](https://www.illumina.com/documents/products/technotes/technote_Q-Scores.pdf)
- [https://gatk.broadinstitute.org/hc/en-us/articles/360035531872-Phred-scaled-quality-scores](https://gatk.broadinstitute.org/hc/en-us/articles/360035531872-Phred-scaled-quality-scores)
- [https://zymoresearch.eu/blogs/blog/what-are-phred-scores](https://zymoresearch.eu/blogs/blog/what-are-phred-scores)

:::

### Programmatic quality control

We will use the tool `fastqc` to assess the quality of our sequence reads, rather than inspecting millions of reads by hand ;)

FastQC is a sequence QC analysis tool that reports the per-base quality.



You can read more about FastQC here: https://datacarpentry.org/wrangling-genomics/02-quality-control.html

example output

::: {.callout-tip collapse="true"}
## Exercises

Try reading it’s help page using: fastqc –h
Run fastqc on the reads in “/workspace/gitpod-bioinf-env/training/data/fastq” using a glob pattern or a for loop.
Inspect the output.
:::


## FastQ Screen


FastQ Screen is an utility that allows you to screen your `FASTQ` reads against a panel of genomes or known contaminants, like [PhiX](https://knowledge.illumina.com/instrumentation/general/instrumentation-general-reference_material-list/000001527), to determine the origin of your sequences. Under the hood, it uses a sequence aligner like `bowtie` or `bwa`, the latter of which we will use in the alignment or mapping chapter.

[The full documentation for FastQ Screen can be found [here](https://stevenwingett.github.io/FastQ-Screen/).]{.aside}

Here is a short video introduction to the software:

{{< video https://www.youtube.com/watch?v=8IsGdikLhaE >}}



Below we show an example of the output generated by FastQ Screen.


Map your reads against a range of reference genomes
–Any species you normally work with
–Common lab contaminants (E coli and Human)
–Artificial sequences (adapters, vectors)
–Known problematic sequences (rRNA)
•Classify matches as
–Unique to one species
–Single or multiple mapping



![Example output of FastQ Screen](../assets/fastq-screen.png)

## Trimmining - `trimmomatic`

Trimmomatic is a tool that can:
Trim low quality bases at the start and end of sequences
Filter low quality reads (e.g., too short after trimming)
Remove adapter sequences used during the library prep and sequencing steps (e.g. Nextera, TrueSeq)


There exist many alternative tools like fastp, Cutadapt and Trim Galore (a wrapper around Cutadapt and FastQC).


Usage:
       PE [-version] [-threads <threads>] [-phred33|-phred64] [-trimlog <trimLogFile>] [-summary <statsSummaryFile>] [-quiet] [-validatePairs] [-basein <inputBase> | <inputFile1> <inputFile2>] [-baseout <outputBase> | <outputFile1P> <outputFile1U> <outputFile2P> <outputFile2U>] <trimmer1>..

Note: PE stands for paired-end reads.

Command options for `trimmomatic`:

|     Option            |     Meaning                                                                                                                   |
|-----------------------|-------------------------------------------------------------------------------------------------------------------------------|
|     inputFile1/2      |     The input .fastq   reads (.gz compression is allowed)                                                                     |
|     outputFile1/2P    |     Name of output file containing   the paired reads from fastq   pair 1/2.                                                  |
|     outputFile1/2U    |     Name of output file containing   the unpaired reads from read pair 1/2 (e.g., when its matching read was   discarded).    |
|     ILLUMINACLIP      |     Perform adapter removal                                                                                                   |
|     SLIDINGWINDOW     |     Perform sliding window trimming,   cutting once the average quality within the window falls below a threshold.            |
|     LEADING           |     Cut bases off at the start of a   read, if the quality is below the threshold                                             |
|     TRAILING          |     Cut bases off at the end of a   read, if the quality is below the threshold                                               |



::: {.callout-note}
## Speeding up code through multi-threading

Multi-threading: increase the number of CPUs used by parallelizing tasks.

Not all analyses can be parallelized, but some like mapping scales quite nicely (up to a limit), because all steps are independent of each other.

For trimmomatic, you can use the option --threads.

cf. built-into tools, job submission on supercomputer, workflow languages, gnu parallel, etc. e.g. parallel downloads

emberassingly parallel
:::
